/*****************************************************************************
*  <システム>   分散処理フレームワーク
*  <名称>	パイプ通信API
*  <目的>	
*  <機能>		
*  <開発環境>	UNIX
*  <特記事項>
*
*  VERSION	  DATE		BY			   CHANGE/COMMENT
*  -----------------------------------------------------------------------------
*  V0.00		2014/06/21  Takakusaki	   新規作成
******************************************************************************/
#include "xi_common.h"

/*****************************************************************************
 プロトタイプ宣言
******************************************************************************/
static u_long l_pipe_data_size=0;

/*****************************************************************************
*  <関数名>	 pipeSelect
*  <機能>	 同期Ｉ／Ｏ
*  <説明>	 指定されたディスクプリターが使用可能となるまでまつ
*  <引数>	   
*		fd:I:ファイルディスクプリタ
*		type:I:チェックタイプ(0=読込みチェック 1=書込みチェック 2=OOBチェック)
*		tm:I:タイムアウト
*  <リターン値> 
*		0:タイムアウト
*		-1:異常終了
*		1:送受信可能
*  <備考>
******************************************************************************/
static int pipeSelect(int fd, int type, int tm) {
	int ret;
	fd_set cset;
	struct timeval timer;

	/* タイムアウト値設定 */
	if ( tm == 0 ){
		timer.tv_sec=0;
		timer.tv_usec=0;
	}else{
		timer.tv_sec = tm/1000000;
		timer.tv_usec = tm%1000000;
	}

	/* 検査するディスクリプターの設定 */
	FD_ZERO(&cset);
	FD_SET(fd, &cset);

	switch(type){
	case 0: /* 読み取り可能チェック */
		ret=select(fd+1, &cset, 0, 0, &timer); break;
	case 1: /* 書き込み可能チェック */
		ret=select(fd+1, 0, &cset, 0, &timer); break;
	case 2: /* 帯域外データOOB(Out Of Bounds)の受信チェック */
		ret=select(fd+1, 0, 0, &cset, &timer); break;
	default:
		return -1;
	}

	/* 異常 */
	if ( ret < 0 ){ return -1; }

	/* タイムアウト */
	if ( ret == 0 ){ return 0; }

	/* チェック */
	if ( FD_ISSET(fd, &cset) == 0){
		return 0;
	}

	return 1;
}

/*****************************************************************************
*  <関数名>	 pipeCreate
*  <機能>	 パイプの作成
*  <説明>	 パイプを作成する
*  <引数>	   
*  <リターン値> 
*		0以上:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int pipeCreate(int *fdes){
	l_pipe_data_size=0;
	//return pipe2(fdes,O_NONBLOCK);
	return pipe(fdes);
}

/*****************************************************************************
*  <関数名>	 pipeRecv
*  <機能>	   パイプ受信
*  <説明>	   パイプからの受信を行う
*  <引数>	   fd:I:ファイルディスクプリター
*		buffer:O:受信データ
*		size:I:受信サイズ
*		timeout:I:タイムアウト
*  <リターン値> 
*		0以上:正常終了(受信サイズ)
*		0未満:異常終了
*  <備考>
******************************************************************************/
int pipeRecv(int fd, char* buffer, int size, int timeout ){
	int ret;

	/* 待ち */
	ret=pipeSelect(fd, 0, timeout); 
	if ( ret < 0 ) return -2;
	if ( ret == 0 ) return 0;
	
	/* 受信 */
	ret=read( fd, buffer, size);
	if ( ret < 0){ return -4; }
	l_pipe_data_size -= ret;
	return ret;
}

/*****************************************************************************
*  <関数名>	 pipeSend
*  <機能>	   パイプ書き込み
*  <説明>	   パイプへの書き込みを行う
*  <引数>	   fd:I:ファイルディスクプリター
*		buffer:I:送信データ
*		size:I:送信サイズ
*		timeout:I:タイムアウト
*  <リターン値> 
*			0:正常終了
*		   0以下:異常終了
*  <備考>
******************************************************************************/
int pipeSend(int fd, char* buffer, int size, int timeout ){
	int ret;

	/* 待ち */
	ret=pipeSelect(fd, 1, timeout);
	if ( ret < 0 ) return -2;
	if ( ret == 0 ) return -3;

	/* 送信 */
	ret=write( fd, buffer, size);
	if ( ret != size ){
		return -4;
	}

	l_pipe_data_size += ret;
	return ret;
}

/*****************************************************************************
*  <関数名>		pipeClose
*  <機能>		パイプクローズ
*  <説明>		パイプのクローズを行う
*  <引数>	   
*			fd:I:ファイルディスクプリター
*  <リターン値> 
*			0:正常終了
*		   -1:異常終了
*  <備考>
******************************************************************************/
int pipeClose(int *fd){
	int ret1;
	int ret2;

	if ( fd[0] >= 0 ){
		ret1=close(fd[0]);
	}
	if ( fd[1] >= 0 ){
		ret2=close(fd[1]);
	}
	if ( ret1 < 0 || ret2 < 0 ){ return -1; }
	l_pipe_data_size=0;
	return 0;
}

