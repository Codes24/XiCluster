/*****************************************************************************
*  <システム>   分散処理フレームワーク
*  <名称>	IPCプロセス間通信API
*  <目的>	
*  <機能>	
*  <開発環境>	UNIX
*  <特記事項>
*
*  VERSION	  DATE		  BY			  	CHANGE/COMMENT
*  -----------------------------------------------------------------------------
*  V0.00	  2014/01/18  Takakusaki		新規作成
******************************************************************************/
#include "xi_common.h"

/*****************************************************************************
 ローカルシンボル定義
******************************************************************************/

/*****************************************************************************
 UNION
******************************************************************************/
union semun {
	int		   val;				/* value forSETVAL */
	struct semid_ds * buf;		/** buffer forIPC_STAT&IPC_SET*/
	unsigned short  * array;	/* array for GETALL & SETALL */
};

/*****************************************************************************
 ローカル関数
******************************************************************************/
static int ipcSemCtl(int,unsigned short *,short *,short *,int);

/*****************************************************************************
*  <関数名>	 ipcMquCreat
*  <機能>	   メッセージキューの作成
*  <説明>	指定されたキーでメッセージキューを作成する
*  <引数>	
*		key:I:キー
*		mqid:O:メッセージキュー識別子
*  <リターン値> 
* 		1:既に存在する
*		0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcMquCreat(key_t key, int *mqid)
{
	*mqid=(-1);
	/* メッセーシ゛キューが存在するか？ */
	if ( (*mqid=msgget(key,0)) >= 0) {
		return 1;
	}
	/* メッセーシ゛キューの作成 */
	if ( (*mqid=msgget(key,IPC_CREAT | 0666)) < 0) {
		return -1;
	}
	return 0;
}
/*****************************************************************************
*  <関数名>	 ipcMquOpen
*  <機能>	   メッセージキューのオープン
*  <説明>	指定されたキーのメッセージキューをオープンする。
*  <引数>	key:I:キー
*		mqid:O:メッセージキュー識別子
*  <リターン値> 0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcMquOpen(key_t key, int *mqid)
{
	*mqid=(-1);
	/* メッセーシ゛キューのオーフ゜ン */
	if ( (*mqid=msgget(key,0)) < 0) {
		return -1;
	}
	return 0;
}
/*****************************************************************************
*  <関数名>	 ipcMquSend
*  <機能>	   メッセージキューへの送信
*  <説明>	指定されたメッセージ情報をメッセージキューに送信する。
*  <引数>	mqid:I:メッセージキュー識別子
*		msg:I:送信メッセージ情報
*		msize:I:送信メッセージサイズ
*  <リターン値> 0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcMquSend(int mqid, char	*msg, int	 msize)
{
	int ret;
	/* メッセーシ゛の送信 */
	if ( (ret=msgsnd(mqid, msg, msize,IPC_NOWAIT)) != 0) {
		/*if ( errno == EAGAIN ) { return 1; } */
		return -1;
	}
	return 0;
}


/*****************************************************************************
*  <関数名>	 ipcMquRecv
*  <機能>	 メッセージキューから自プロセス向けデータを受信
*  <説明>	メッセージキューから自プロセス向けのメッセージ情報を受信して結果を返す
*  <引数>	
*		mqid:I:メッセージキュー識別子
*		msg:O:メッセージ情報
*		msize:I:受信バッファサイズ
*		mtype:I:メッセージ番号
*  <リターン値> 
*		1以上:正常終了
*		0:データなし
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcMquRecv(int mqid, char *msg, int msize, int mno)
{
	int ret;
	/* メッセーシ゛の受信 */
	ret=msgrcv(mqid, msg, msize, mno, IPC_NOWAIT);
	/* メッセーシ゛無し */
	if ( ret==(-1) && errno==ENOMSG ) {
		return 0;
	}
	/* 受信異常 */
	if ( ret == (-1) ) {
		return -1;
	}
	return 1;
}

/*****************************************************************************
*  <関数名>	 ipcMquInfo
*  <機能>	   メッセージキュー情報取得
*  <説明>	メッセージキューの最大数、現在数、現在サイズを取得する。
*  <引数>	
*		mqid:I:メッセージキュー識別子
*		max:O:メッセージキュー内最大個数
*		cnt:O:現在メッセージキューに溜まっているメッセージ数
*		si:O:現在メッセージキューに溜まっているメッセージサイズ
*  <リターン値> 
*		0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcMquInfo(int mqid, int *max, int *cnt, int *si)
{
	struct msqid_ds msqid_ds;
	/* 初期化 */
	*max=0;
	*cnt=0;
	*si=0;
	/* メッセーシ゛キュー内情報の取得 */
	if ( msgctl(mqid, IPC_STAT, &msqid_ds) < 0) {
		return -1;
	}

	/* 情報を返す */
	*max = msqid_ds.msg_qbytes;
	*cnt = msqid_ds.msg_qnum;
	*si = msqid_ds.msg_cbytes;
	return 0;
}
/*****************************************************************************
*  <関数名>	 ipcMquClose
*  <機能>	   メッセージキューの削除
*  <説明>	指定されたキーのメッセージキューを削除する。
*  <引数>	mqid:I:メッセージキュー識別子
*  <リターン値> 0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcMquClose(int mqid)
{
	/* メッセーシ゛キューの削除 */
	if ( msgctl(mqid, IPC_RMID,0) < 0) {
		return -1;
	}
	return 0;
}
/*****************************************************************************
*  <関数名>	 ipcSemCreat
*  <機能>	   セマフォの作成
*  <説明>	引数で指定されたキー、指定された個数でセマフォ配列の作成する。
*  <引数>	
*		key:I:セマフォキー値
*		nums:I:ハイ列数
*		semid:O:セマフォ識別子
*  <リターン値> 
*		1:既に存在する
*		0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcSemCreat(key_t key, int nums, int *semid)
{
	int i;
	union   semun arg;

	/* 同一キーでのセマフォが存在するか？ */
	if ( (*semid=semget(key,0,0)) >= 0) {
		return 1;
	}

	/* セマフォの作成 */
	if ( (*semid=semget(key, nums, IPC_CREAT | 0666)) < 0) {
		return -1;
	}
	/* セマフォ値を１に初期化する */
	arg.val = 1;
	for (i=0; i<IPC_SEM_NSEMS; i++) {
		if (semctl(*semid, i, SETVAL, arg ) < 0) {
			semctl(*semid,0,IPC_RMID,0);
			*semid=-1;
			return -1;
		}
	}

	return 0;
}
/*****************************************************************************
*  <関数名>	 ipcSemOpen
*  <機能>	   セマフォのオープン
*  <説明>	指定されたキーでセマフォをオープンする。
*  <引数>	key:I:セマフォキー値
*		semid:O:セマフォ識別子
*  <リターン値> 0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcSemOpen(key_t key, int *semid)
{
	/* セマフォのオーフ゜ン */
	if ( (*semid=semget(key, 0, 0)) < 0) {
		return -1;
	}
	return 0;
}
/*****************************************************************************
*  <関数名>	 ipcSemCtl
*  <機能>	   セマフォ配列の操作
*  <説明>	指定されたセマフォ識別子に対するセマフォ配列のｎｏ番目のセマフォを操作する。
*		ｏｐにはロック時は−１を、アンロック時は１を指定する。
*		ｆｌｇには通常SEM_UNDOを指定して、自プロセスが異常終了した時にＯＳがロッックを解除する様に指定する。
*		ｎｏｐｓは操作する配列数を指定する（通常は１を指定する）。
*  <引数>	semid:I:セマフォ識別子
*		no:I:セマフォ配列番号
*		op:I:セマフォ操作
*		flg:I:セマフォ操作パラメータ
*		nops:I:セマフォ配列を処理する数
*  <リターン値> 0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
static int ipcSemCtl(int semid, ushort  *no, short *op, short *flg, int nops)
{
	int i,ret;
	struct sembuf ss;
	for (i=0; i<nops; i++) {
		ss.sem_num=no[i];
		ss.sem_op =op[i];
		ss.sem_flg=flg[i];
/* printf("[IPC%d] ipcSemCtl(%d,ss,1) [%d,%d,%d]\n",semid,  no[i],op[i],flg[i]); */
		if ( (ret=semop(semid, &ss, 1)) < 0) {
			return -1;
		}
	}
	return 0;
}
/*****************************************************************************
*  <関数名>	 ipcSemClose
*  <機能>	   セマフォの削除
*  <説明>	指定されたキーのセマフォを削除する。
*  <引数>	semid:I:セマフォ識別子
*  <リターン値> 0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcSemClose(int semid)
{
	/* セマフォの削除 */
	if ( semctl(semid, 0, IPC_RMID) < 0) {
		return -1;
	}
	return 0;
}
/*****************************************************************************
*  <関数名>	 ipcSemLock
*  <機能>	   資源のロック
*  <説明>	指定されたセマフォの指定された配列番号の資源をロックする。
*  <引数>	
		semid:I:セマフォ識別子
*		smno:I:セマフォ配列番号
*  <リターン値> 0以上:正常終了(試行回数)
*		-1:異常終了
*		-2:異常終了(RETRY OVER)
*
*  <備考> 	【セマフォ操作フラグ指定時の注意】
*		(1)SEM_UNDOはプロセスが異常終了した際にカーネルがセマフォ値を元に戻す機能です 
*		(2)任意のセマフォに対してアンドゥ処理を保留できるプロセスの最大数は決まっています 
*			SEM_UNDOオプションをつけた場合は、この制限を越えるとENOSPCエラーとなります
*			/etc/systemのシステムパラメータseminfo_semmnuで設定できます 
*		(3)SEM_UNDOフラグを指定した場合はUnLock時も指定する
*		(4)IPC_NOWAITフラグ指定時にロック中の場合はEAGAINエラーとなる
******************************************************************************/
int ipcSemLock(int  semid, int smno, int retry, int retrans )
{
	int ret;
	int i;

	unsigned short no[5];
	short  op[5];
	short  flg[5];
	/* セマフォ制御情報の設定 */
	no[0]  = (unsigned short)smno;
	op[0]  = -1;
	/* flg[0] = IPC_NOWAIT | SEM_UNDO; */
	flg[0] = IPC_NOWAIT | SEM_UNDO;

	/* セマフォ操作 */
	for ( i=0; i<retry; i++){
		if ( ipcSemCtl(semid, no, op, flg, 1) == 0) break;
/*
		if ( errno == ENOSPC ){
			usleep(retrans);
			errno=ENOSPC;
			continue;
		}
*/
		if ( errno == EAGAIN ){
			usleep(retrans);
			errno=EAGAIN;
			continue;
		}
		return -1;
	}
	if ( i >= retry ) return -2;

	return i;
}
/*****************************************************************************
*  <関数名>	 ipcSemUnLock
*  <機能>	   共有資源のアンロック
*  <説明>	指定されたセマフォの指定された配列番号の資源を解放する。
*  <引数>	semid:I:セマフォ識別子
*		smno:I:セマフォ配列番号
*  <リターン値> 0:正常終了
*		-1:異常終了
*		-2:異常終了(OVER)
*  <備考>
******************************************************************************/
int ipcSemUnLock(int  semid, int smno, int retry, int retrans)
{
	int i,ret;
	ushort no[5];
	short  op[5];
	short  flg[5];

	/* セマフォ制御情報の設定 */
	no[0]  = (unsigned short)smno;
	op[0]  = 1;
	/* flg[0] = IPC_NOWAIT | SEM_UNDO; */
	flg[0] = SEM_UNDO;

	/* セマフォ操作 */
	for ( i=0; i<retry; i++){
		if ( ipcSemCtl(semid, no, op, flg, 1) == 0) break;
/*
		if ( errno == ENOSPC ){
			usleep(retrans);
			continue;
		}
*/
		if ( errno == EAGAIN ){
			usleep(retrans);
			continue;
		}
		return -1;
	}
	if ( i >= retry ) return -2;

	return 0;
}
/*****************************************************************************
*  <関数名>	 ipcSemInf
*  <機能>	   セマフォ情報の取得
*  <説明>	現在のセマフォ配列の値を取得する。
*  <引数>	semid:I:セマフォ識別子
*		vol:O:セマフォ値
*  <リターン値> 0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcSemInf(int semid, int *val)
{
	int i;
	union semun arg;
	ushort wk[IPC_SEM_NSEMS];

	arg.array = wk;
	if ( semctl(semid, 0, GETALL, arg) < 0) {
		return -1;
	}
	for ( i=0; i<IPC_SEM_NSEMS; i++) {
		val[i]=arg.array[i];
	}
	return 0;
}
/*****************************************************************************
*  <関数名>	 ipcSemSet
*  <機能>	   セマフォ値の設定
*  <説明>	指定されたセマフォ配列番号のセマフォ値を変更する。
*  <引数>	semid:I:セマフォ識別子
*		smno:I:配列番号
*		vol:I:セマフォ値
*  <リターン値> 0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcSemSet(int semid, int smno, int val)
{
	union semun arg;
	arg.val=val;
	if ( semctl(semid, smno, SETVAL, arg) < 0) {
		return -1;
	}
	return 0;
}
/*****************************************************************************
*  <関数名>	 ipcShmCreat
*  <機能>	   共有メモリの作成
*  <説明>	引数で指定されたキー、で指定されたサイズの共有メモリを作成する。
*  <引数>	key:I:共有メモリキー値
*		ssize:I:作成サイズ
*		shmid:O:共有メモリ識別子
*  <リターン値> 
*		1:既に存在する
*		0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcShmCreat(key_t key, int ssize, int *shmid)
{
	*shmid = -1;
	/* 共有メモリが存在するか？ */
	if ( (*shmid=shmget(key,0,0)) > 0 ){
		return 1;
	}

	/* 共有メモリ作成 */
	if ( (*shmid=shmget(key, ssize, IPC_CREAT | 0666)) < 0) {
		*shmid = -1;
		return -1;
	}
	return 0;
}
/*****************************************************************************
*  <関数名>	 ipcShmOpen
*  <機能>	   共有メモリのアタッチ
*  <説明>	指定されたキー値の共有メモリをオープンする。
*  <引数>	key:I:共有メモリキー値
*		shmid:O:共有メモリ識別子
*  <リターン値> 0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcShmOpen(key_t key, int *shmid)
{
	/* 共有メモリのオープン */
	if ( (*shmid=shmget(key, 0, 0)) < 0) {
		*shmid = -1;
		return -1;
	}
	return 0;
}

/*****************************************************************************
*  <関数名>	 ipcShmAttch
*  <機能>	   共有メモリのアタッチ
*  <説明>	共有メモリをアタッチする。
*  <引数>	shmid:I:共有メモリ識別子
*  <リターン値> NULL以外:共有メモリ先頭アドレス
*		NULL:異常終了
*  <備考>
******************************************************************************/
char *ipcShmAttch(int shmid)
{
	char *addr=NULL;
	/* 共有メモリのアタッチ */
	addr=(char*)shmat(shmid, 0, SHM_RND);
	if ( addr == (char*)-1 ) {
		return NULL;
	}
	if ( addr <= (char*)0 ) {
		return NULL;
	}
	return addr;
}

/*****************************************************************************
*  <関数名>	 ipcShmInfo
*  <機能>	   共有メモリの情報取得
*  <説明>	共有メモリ情報を取得する。
*  <引数>	shmid:I:共有メモリ識別子
*		attch:O:アタッチ数
*		cpid:O:作成者
*  <リターン値> 0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcShmInfo(int shmid, int *attch, int *cpid)
{
	struct shmid_ds buf;

	*attch=0;
	*cpid=0;
	/* 情報取得 */
	if ( shmctl(shmid,IPC_STAT,&buf) < 0) {
		return -1;
	}
	*attch=buf.shm_nattch;
	*cpid=buf.shm_cpid;
	
	return 0;
}

/*****************************************************************************
*  <関数名>	 ipcShmClose
*  <機能>	   共有メモリの削除
*  <説明>	指定されたキーの共有メモリをデタッチし削除する。
*  <引数>	shmid:I:共有メモリ識別子
*		addr:I:共有メモリ先頭アドレス
*  <リターン値> 0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcShmClose(int shmid, char  *addr)
{
	/* 共有メモリセグメントのデタッチ */
	if ( shmdt(addr) < 0) {
		return -1;
	}
	/* 共有メモリセグメントの削除 */
	if ( shmctl(shmid,IPC_RMID,NULL) < 0) {
		return -1;
	}
	return 0;
}
/*****************************************************************************
*  <関数名>	 ipcShmFin
*  <機能>	   共有メモリのデタッチ
*  <説明>	指定されたアドレスの共有メモリをデタッチする。
*  <引数>	addr:I:共有メモリ先頭アドレス
*  <リターン値> 0:正常終了
*		-1:異常終了
*  <備考>
******************************************************************************/
int ipcShmFin(char	*addr)
{
	/* 共有メモリセグメントのデタッチ */
	if ( shmdt(addr) < 0) {
		return -1;
	}
	return 0;
}
